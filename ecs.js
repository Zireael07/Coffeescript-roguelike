// Generated by CoffeeScript 2.5.0
  // based on Python's Esper module
var World,
  indexOf = [].indexOf;

import {
  intersect_lists,
  remove_list
} from './intersection.js';

World = class World {
  constructor() {
    this.processors = [];
    // for processors added on the fly
    this.to_execute = [];
    this.next_entity_id = 0;
    this.components = {};
    this.entities = {};
    this.dead_entities = new Set();
  }

  clear_database() {
    // remove all entities and components from World
    this.next_entity_id = 0;
    this.components.length = 0;
    this.entities.length = 0;
    return this.dead_entities.length = 0;
  }

  add_processor(processor) {
    // Add processor to the world
    processor.world = this;
    return this.processors.push(processor);
  }

  add_and_run_processor(processor) {
    // Add a processor to the world
    processor.world = this;
    this.processors.push(processor);
    this.to_execute.push(processor);
  }

  //console.log "Added a processor..."
  remove_processor(processor_type) {
    var i, len, processor, ref;
    ref = this.processors;
    // Remove processor by type
    for (i = 0, len = ref.length; i < len; i++) {
      processor = ref[i];
      // check type
      if (processor instanceof processor_type) {
        processor.world = null;
        // remove from array
        //@processors.filter(item => item != processor) # !== in JS
        this.processors = remove_list(this.processors, processor); // avoid implicit return
      }
    }
  }

  //console.log @processors
  get_processor(processor_type) {
    var i, len, processor, ref;
    ref = this.processors;
    for (i = 0, len = ref.length; i < len; i++) {
      processor = ref[i];
      // check type
      //console.log processor instanceof processor_type
      if (processor instanceof processor_type) {
        return processor;
      }
    }
  }

  create_entity(components) {
    var component, i, len;
    this.next_entity_id += 1;
    //console.log components
    // prevent crash
    if (components !== void 0) {
      for (i = 0, len = components.length; i < len; i++) {
        component = components[i];
        //console.log component
        this.add_component(this.next_entity_id, component);
      }
    }
    return this.next_entity_id;
  }

  delete_entity(entity) {
    // Perform delayed deletion
    return this.dead_entities.add(entity);
  }

  component_for_entity(entity, component) {
    var component_type;
    component_type = component.name; //get our %$^$ type
    //console.log component_type
    //console.log @entities[entity][component_type]
    return this.entities[entity][component_type];
  }

  //components_for_entity: (entity) ->
  // Returns all components for entity
  // useful for saving state
  has_component(entity, component_type) {
    //console.log(component_type)
    //console.log(component_type in @entities[entity])
    return indexOf.call(this.entities[entity], component_type) >= 0;
  }

  add_component(entity, component) {
    var component_type;
    component_type = component.constructor.name; //get our %$^$ type
    //#console.log component.constructor.name
    if (!(component_type in this.components)) { // object presence 
      //#console.log component_type of @components
      this.components[component_type] = [];
    }
    //#console.log @components[component_type]

    // effectively same as a set
    if (indexOf.call(this.components[component_type], entity) < 0) {
      this.components[component_type].push(entity);
    }
    if (!(entity in this.entities)) {
      this.entities[entity] = {};
    }
    return this.entities[entity][component_type] = component;
  }

  remove_component(entity, component) {
    var component_type;
    // Remove a component by type
    component_type = component.name; // get our %$^#$ type
    //console.log component_type
    //console.log @components[component_type]
    //@components[component_type].filter(item => item != entity)
    this.components[component_type] = remove_list(this.components[component_type], entity);
    if (!this.components[component_type]) {
      delete this.components[component_type];
    }
    delete this.entities[entity][component_type];
    if (!this.entities[entity]) {
      delete this.entities[entity];
    }
  }

  
    // internals
  * get_int_component(component_type) {
    var entity, i, len, ref, results;
    //console.log component_type of @components
    // crash fix
    if (!(component_type in this.components)) {
      return null;
    }
    ref = this.components[component_type];
    //console.log "Get int for: " + component_type
    //console.log "Get internal: " + @components[component_type]
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      entity = ref[i];
      //console.log entity
      results.push((yield [entity, this.entities[entity][component_type]]));
    }
    return results;
  }

  * get_int_components(...component_types) {
    var ct, entity, i, inters, j, k, len, len1, len2, lists, results, ret;
    lists = [];
    for (i = 0, len = component_types.length; i < len; i++) {
      ct = component_types[i];
      // Gets an iterator for multiple component types
      lists.push(this.components[ct]);
    }
    //console.log "Lists: " + lists
    inters = intersect_lists(lists);
//console.log "Intersection: " + inters
    results = [];
    for (j = 0, len1 = inters.length; j < len1; j++) {
      entity = inters[j];
      //console.log "Ent in inters: " + entity
      ret = [];
      for (k = 0, len2 = component_types.length; k < len2; k++) {
        ct = component_types[k];
        ret.push(this.entities[entity][ct]);
      }
      //console.log ret
      results.push((yield [entity, ret]));
    }
    return results;
  }

  // public API
  get_component(component_typeclass) {
    var component_type, query, res, results;
    //console.log "Getting... " + component_typeclass.name
    component_type = component_typeclass.name; //get our %$^$ type
    res = this.get_int_component(component_type);
    results = [];
    for (query of res) {
      //console.log(res)
      results.push(query);
    }
    return results;
  }

  get_components(...component_typesclass) {
    var component_types, i, len, query, ref, results, type;
    component_types = [];
    for (i = 0, len = component_typesclass.length; i < len; i++) {
      type = component_typesclass[i];
      component_types.push(type.name); // get our #$%#@# type
    }
    ref = this.get_int_components(...component_types);
    results = [];
    for (query of ref) {
      results.push(query);
    }
    return results;
  }

  clear_dead_entities() {
    var component_type, entity, ref;
    ref = this.dead_entities;
    // it's a set!
    //Finalize deletion of any Entities that are marked dead
    for (entity of ref) {
//console.log ("Clearing dead..." + entity)
//console.log @entities[entity]
      for (component_type in this.entities[entity]) {
        //console.log "Removing from component " + component_type + " lists... " + entity
        //@components[component_type].delete entity
        //console.log "Before deletion..."
        console.log(this.components[component_type]);
        this.components[component_type] = remove_list(this.components[component_type], entity);
        //console.log "After deletion..."
        console.log(this.components[component_type]);
        if (!this.components[component_type]) {
          delete this.components[component_type];
        }
      }
      delete this.entities[entity];
      delete this.dead_entities[entity];
    }
    //console.log @entities
    this.dead_entities.clear(); // avoid implicit return
  }

  _process() {
    var i, len, processor, ref, results;
    ref = this.processors;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      processor = ref[i];
      //console.log processor
      results.push(processor.process());
    }
    return results;
  }

  _execute() {
    var i, len, processor, ref;
    ref = this.to_execute;
    //console.log "Executing..."
    // any that were added on the fly
    for (i = 0, len = ref.length; i < len; i++) {
      processor = ref[i];
      console.log(processor + " to execute ");
      processor.process();
      this.to_execute = remove_list(this.to_execute, processor); // avoid implicit return
    }
  }

  process() {
    //Call the process method on all Processors
    // In addition, all entities that were marked for deletion since the last call will be deleted
    this.clear_dead_entities();
    this._process();
    this._execute(); // avoid implicit return
  }

};

export {
  World
};
